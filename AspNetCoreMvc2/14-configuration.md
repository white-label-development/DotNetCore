## 14-Configuration
`Program` and 'Startup' (Program runs first. It's the entry point) both handle configuration. 
Allows applications to be tailored to their environment 
(Program.Main calls BuildWebHost, which is responsible for configuring ASP.NET Core)

`Startup` creates services and middleware components (which are used to handle HTTP requests, much like the old OWIN pipeline)

The most important configuration file is \<projectname\>.csproj, which replaces the project.json file used in earlier versions of ASP.NET Core.
The csproj file is used to configure the MSBuild tool

The BuildWebHost method uses static methods defined by the WebHost class to configure ASP.NET Core. 
With the release of ASP.NET Core 2, the configuration is simplified by the use of the `CreateDefaultBuilder` method, 
which configures ASP.NET Core using settings that are likely to suit most projects. 

The UseStartup method is called to identify the class that will provide application-specific configuration; 
the convention is to use a class called Startup. 

The `Build()` method processes all the configuration settings and creates an object that implements the IWebHost interface, 

`.Run()` starts handling HTTP requests.

`CreateDefaultBuilder` is convenient, but hides details that are worth knowing about. 

See BuilWebHostManually() in SprtsStore.Program (it's not called, it's just an example)

#### Startup
##### ConfigureServices

When the application starts, ASP.NET Core creates a new instance of the Startup class and calls its `ConfigureServices` method so that the application can create its services. 

eg: first create a class UptimeService, then in `ConfigureServices` add `services.AddSingleton<UptimeService>();`

Controllers (and anything else I guess?) get free DI from services added to the IServiceCollection .


##### Configure
Next, ASP.NET calls the `Configure` method to set up the request pipeline, 
which is the set of components—known as middleware— that are used to handle incoming HTTP requests and produce responses for them.

Next ASP.NET is ready to start handling Requests.

##### Built in MVC Services and ASP.NET Middleware

eg: `services.AddMvc()`

Middleware is the term used for the components that are combined to form the request pipeline.  T
he request pipeline is arranged like a chain, and when a new request arrives, 
it is passed to the first middleware component in the chain. 
This component inspects the request and decides whether to handle it and generate a response or 
to pass it to the next component in the chain. 
Once a request has been handled, the response that will be returned to the client is passed back along the chain, 
which allows all of the earlier components to inspect or modify it (request goes through the pipeline, hits the "backstop" then back the other way and out to the client)


##### Content-Generating Middleware

Such as MVC. See `SportsStore.Infrastructure.ContentMiddleware` which is registered in Configure() 
as `app.UseMiddleware<ContentMiddleware>(); `

##### Short-Circuiting Middleware

Intercepts requests before they reach the content generation components in order to short-circuit the pipeline process, often for performance purposes.

This type of middleware doesn’t always forward requests to the next component in the chain. 

In the case of `portsStore.Infrastructure.ShortCircuitMiddleware`, if the User-Agent header contains the term edge, 
the component sets the status code to 403 – Forbidden and doesn’t forward the request to the next component. 
Since the request is being rejected, there is no point in allowing the request to be handled by other components, which would needlessly consume system resources. 
Instead, the request handling is terminated early, and the 403 response is sent to the client. 

##### Request-Editing Middleware

Changes requests before they reach other components later in the chain.

This kind of middleware is mainly used for platform integration to enrich the ASP.NET Core representation of an HTTP request with platform-specific features. 
It can also be used to prepare requests so that they are easier to process by subsequent components

####' Response-Editing Middleware 

The final type of middleware operates on the responses generated by other components in the pipeline. 
This is useful for logging details of requests and their responses or for dealing with errors

Response-Editing Middleware needs to be registered first as it can only inspect middleware declared after it. 
anything before is unavailable. see `SportsStore.Infrastructure.ErrorMiddleware`

##### Configure Exception Handling

see `app.UseExceptionHandler("/Home/Error")`


#### appsettings.json

Can contain any data, not just config stuff. eg:
```
{  "ShortCircuitMiddleware": { "EnableBrowserShortCircuit": true } }
```
then (in Configure)

```
if ((Configuration.GetSection("ShortCircuitMiddleware")?
  .GetValue<bool>("EnableBrowserShortCircuit")).Value) { ... }
```

Can be used to configure logging, eg:
```
  "Logging": {
    "LogLevel": {
      "Default": "Debug",
      "System": "Information",
      "Microsoft": "Information"
    }
  }
```
LoggingLevels: Trace, Debug, Information, Warning, Error, Critical, None.

Default: Debug (or greater)
System and Microsoft (overrides) refer to logging levels for specific Namespaces

##### Custom Log Messages
In NeilController add `private ILogger<NeilController> logger;` set with ctor injections, 
then `logger.LogDebug("whatevs");`

Does not see to need the service defining in Startup. Maybe part of `services.AddMvc();` ?


#### Environment specific configuration

Add methods which override to `Startup`, eg: `ConfigureDevelopmentServices(IServiceCollection services)`

or add class based overrides eg `StartupDevelopment` will replace `StartupDevelopment` (in development)

Enable Environment-Specific Startup in the Program.cs File `.UseStartup(nameof(SportsStore))` , as opposed to `.UseStartup<Startup>()`

(Rather than specifying a class, the UseStartup method is given the name of the assembly that it should use. When the application starts, ASP.NET will look for a class whose name includes the hosting environment, such as StartupDevelopment or StartupProduction, and fall back to using the regular Startup class if one does not exist.)








